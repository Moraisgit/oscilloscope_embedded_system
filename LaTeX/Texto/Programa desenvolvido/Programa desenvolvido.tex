De modo a cumprir as funções especificadas no enunciado, tomaram-se como base os \textit{scripts} fornecidos pelos docentes (\texttt{main\_exemplo\_1.py} e \texttt{main\_exemplo\_2.py}) para o desenvolvimento do programa \texttt{main.py}.

Nesta secção serão apresentadas porções do código consideradas mais importantes para a sua perceção do ponto de vista do leitor. Para erradicar quaisquer dúvidas, o código completo encontra-se no \autoref{ap:Ficheiro de código desenvolvido completo} e devidamente comentado. \newline

Primeiramente reconheçam-se as variáveis globais utilizadas, com especial atenção para as variáveis das linhas \texttt{15}, \texttt{16}, \texttt{21} e \texttt{22} que correspondem à informação de um sinal em pixeis dos dois eixos (para a representação no \textit{display}) e aos índices dos vetores das escalas para efetuar a mudança de escala consoante o botão premido (no ciclo principal do programa incrementam-se estes índices ao receber \textit{input} dos botões respetivos). Notemos ainda a variável da linha \texttt{31} que, quando a \texttt{True}, possibilita a mudança de escalas e permanecendo na representação do espetro, mudando o seu valor para \texttt{False} aquando da representação no domínio do tempo.

\lstinputlisting[language=Python, label={lst:variaveis}, firstline=8, lastline=32,firstnumber=8]{codigo_completo.py}

O programa principal começa por executar \texttt{reset\_display()} e \texttt{read\_and\_calculate()}. Esta última apresentada abaixo, calcula as tensões a partir dos pontos recolhidos do ADC, determina parte do conjunto de medidas a enviar por email (valor eficaz é calculado à parte com \texttt{calculate\_rms\_value()}) e converte as tensões em pixeis para representar o sinal no \textit{display} através de \texttt{draw\_normal\_plot()}.

\lstinputlisting[language=Python, label={lst:readandcalculuate}, firstline=59, lastline=97,firstnumber=59]{codigo_completo.py}

De seguida inicia-se o ciclo principal do programa onde se espera pelo acionamento de alguma das funções pedidas para desenvolver, através da pressão de um botão por parte do utilizador. Por motivos de extensividade, esse ciclo não é aqui apresentado, mas pode ser consultado em detalhe no \autoref{ap:Ficheiro de código desenvolvido completo}. \newline

Ao pressionar o \textbf{Botão 1}: \uline{Clique rápido -} estamos no domínio do tempo e as escalas voltam ao padrão (modificando as variáveis \texttt{spectrum} e \texttt{index} para tal), de seguida executa-se \texttt{read\_and\_calulate()} e \texttt{draw\_normal\_plot()}, obtendo a representação do sinal no \textit{display}; \uline{Clique lento -} aqui calcula-se a medida em falta \texttt{Vrms} e envia-se um email com esta e as calculadas na medição anterior; \uline{Duplo clique -} calcula-se o conjunto de medidas e são apresentadas no display através de \texttt{reset\_button\_13\_display()}.

Por outro lado, pressionando o \textbf{Botão 2}: \uline{Clique rápido e clique lento -} mudança das escalas vertical e horizontal (respetivamente) através das variáveis \texttt{index} que são incrementadas de modo às escalas dos vetores \texttt{scale} aumentarem sequencialmente e, caso seja a última, voltar à primeira. A variável \texttt{spectrum} é aqui usada para mudar a escala e continuar no domínio da frequência (se for o caso), depois são feitas novas medições e representa-se o sinal no domínio respetivo; \uline{Duplo clique -} aqui é calculada a \textit{Discrete Fourier Transform} (DFT) e o espetro do sinal, com \texttt{dft\_and\_spectrum()} (esta apresentada abaixo), e representado o espetro do sinal com \texttt{draw\_spectrum\_plot()}. No cálculo da DFT começa-se por usar a fórmula apresentada no enunciado, mas uma vez que metade dos valores são redundantes devido a $X_{k}=X_{N-k}^{*}$ (pois o espetro obtém-se a partir dos módulos da transformada de Fourier), apenas se calcula \texttt{X\_k} num ciclo de \texttt{N//2}$-1$ iterações (ignorando o último ponto $k=N/2$ como pedido no enunciado). Este cálculo é ainda feito dois a dois pontos devido à recomendação do enunciado. De seguida, aplica-se a fórmula de $X_{SS_{k}}$, que consta no enunciado, para os valores de \texttt{k} respetivos e estes valores são convertidos para pixeis que irão ser os elementos do vetor das ordenadas \texttt{y\_aux} a devolver (juntamente com \texttt{x\_aux} que consiste no vetor das abcissas, ou seja, frequências).

\lstinputlisting[language=Python, label={lst:dft}, firstline=142, lastline=183,firstnumber=142]{codigo_completo.py}

Outras funções ainda não mencionadas, mas claramente utilizadas ao longo da implementação do ciclo principal do programa, são \texttt{reset\_display()} e \texttt{reset\_spectrum\_display()} que simplesmente efetuam o \textit{reset} do \textit{display} para o domínio do tempo e frequência, respetivamente, no que toca à grelha e ícone de Wi-fi. \newline

Uma outra funcionalidade que podia ter sido desenvolvida seria o clássico \textit{Autoscale}, que haveria de selecionar as melhores escalas vertical e horizontal para proceder à representação de um sinal da melhor maneira possível, assim como também seria possível definir um número de períodos mínimo a representar. 